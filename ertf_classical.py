import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import Clifford, random_clifford, Pauli

def erft(
    U: QuantumCircuit,
    V: QuantumCircuit,
    epsilon: float,
    delta: float,
    seed: int = None
) -> str:
    """
    Determines if two quantum circuits, U and V, are equivalent using the
    Equivalence via Randomized Fidelity Testing (ERFT) algorithm, optimized
    with classical stabilizer simulation.

    Args:
        U: The first quantum circuit (must be Clifford).
        V: The second quantum circuit to compare (must be Clifford).
        epsilon: The error tolerance for equivalence. The fidelity is checked
                 to be >= 1 - epsilon.
        delta: The probability of the estimation failing.
        seed: Optional seed for the random number generator for reproducibility.

    Returns:
        A string indicating whether the circuits are "Equivalent (within ε)"
        or "Not equivalent".
    """
    # --- Validate Inputs ---
    if U.num_qubits != V.num_qubits:
        raise ValueError("Input circuits U and V must act on the same number of qubits.")
    if not (0 < epsilon < 1):
        raise ValueError("Epsilon (ε) must be between 0 and 1.")
    if not (0 < delta < 1):
        raise ValueError("Delta (δ) must be between 0 and 1.")

    num_qubits = U.num_qubits
    print(f"🔬 Starting ERFT for {num_qubits}-qubit circuits (Optimized with Stabilizer Simulation)...")
    print(f"   - ε (error tolerance): {epsilon}")
    print(f"   - δ (failure probability): {delta}")

    # --- Step 1: Convert circuits to Clifford objects ---
    # This is necessary for the stabilizer simulation. This step will fail
    # if the circuits contain non-Clifford gates.
    try:
        cliff_U = Clifford(U)
        cliff_V = Clifford(V)
    except Exception as e:
        raise ValueError(f"Circuits must be Clifford. Error: {e}")

    # --- Step 2: Define the "difference" Clifford operator ---
    # W = U†V. This is all done classically on the tableau representation.
    W = cliff_U.adjoint().compose(cliff_V)

    # --- Step 3: Determine number of samples needed ---
    m = int(np.ceil((1 / (2 * epsilon**2)) * np.log(2 / delta)))
    print(f"   - m (required samples): {m}")

    total_survivals = 0
    rng = np.random.default_rng(seed)

    # --- Step 4: Loop through m samples using classical simulation ---
    print(f"\n🚀 Running {m} randomized trials (classical simulation)...")
    
    # Define the initial state |0...0>. Its stabilizer group is generated
    # by Z on each qubit, i.e., {Z_0, Z_1, ..., Z_{n-1}}.
    initial_stabilizers = [Pauli('I'*i + 'Z' + 'I'*(num_qubits-1-i)) for i in range(num_qubits)]

    for i in range(m):
        # 4a. Sample a random n-qubit Clifford operator C_i
        C_i = random_clifford(num_qubits, seed=int(rng.integers(2**32)))
        
        # 4b. Classically evolve the stabilizers of the |0> state
        # We want to compute the stabilizers of the final state: C_i† * W * C_i |0...0>
        # The evolution of a Pauli P under a Clifford U is U * P * U†.
        # Here, the state evolves as |ψ'> = C_i† W C_i |ψ>, so a stabilizer S of |ψ>
        # evolves to S' = (C_i† W C_i) S (C_i† W C_i)† = C_i† W C_i S C_i† W† C_i
        
        final_stabilizers = []
        for stabilizer in initial_stabilizers:
            # Evolve the stabilizer through the operations in reverse
            evolved_stab = stabilizer.evolve(C_i, frame='operator') # C_i * S * C_i†
            evolved_stab = evolved_stab.evolve(W, frame='operator')   # W * (C_i S C_i†) * W†
            evolved_stab = evolved_stab.evolve(C_i.adjoint(), frame='operator') # C_i† * (W...) * C_i
            final_stabilizers.append(evolved_stab)

        # 4c. Check for "survival"
        # The state is |0...0> if and only if {Z_0, Z_1, ...} is a valid
        # set of stabilizers for the final state. We check if each Z_i
        # is in the group generated by our calculated final stabilizers.
        # A simpler check: the state is |0...0> iff its stabilizers *are* the Z Paulis.
        is_survival = all(p in final_stabilizers for p in initial_stabilizers)

        if is_survival:
            total_survivals += 1

    # --- Step 5: Compute average survival probability ---
    F_hat = total_survivals / m
    print(f"\n📊 Results:")
    print(f"   - Total 'survival' counts: {total_survivals} / {m}")
    print(f"   - Estimated Fidelity (F_hat): {F_hat:.4f}")

    # --- Step 6: Decide equivalence ---
    decision_threshold = 1 - epsilon
    print(f"   - Decision Threshold (1 - ε): {decision_threshold:.4f}")

    if F_hat >= decision_threshold:
        print("   - Outcome: F_hat ≥ 1 - ε")
        return "✅ Equivalent (within ε)"
    else:
        print("   - Outcome: F_hat < 1 - ε")
        return "❌ Not equivalent"

# --- Example Usage ---
if __name__ == '__main__':
    # --- Parameters ---
    N_QUBITS = 2
    EPSILON = 0.1  # 10% error tolerance
    DELTA = 0.05   # 5% chance of failure (95% confidence)

    # --- Case 1: Equivalent Circuits ---
    print("-" * 50)
    print("### Case 1: Testing Equivalent Circuits ###")
    U1 = QuantumCircuit(N_QUBITS, name="U1")
    U1.cx(0, 1)
    V1 = QuantumCircuit(N_QUBITS, name="V1")
    V1.h(1)
    V1.cz(0, 1)
    V1.h(1)
    result_1 = erft(U1, V1, epsilon=EPSILON, delta=DELTA)
    print(f"\nFinal Decision for Case 1: {result_1}\n")

    # --- Case 2: Non-Equivalent Circuits ---
    print("-" * 50)
    print("### Case 2: Testing Non-Equivalent Circuits ###")
    U2 = QuantumCircuit(N_QUBITS, name="U2")
    U2.z(0)
    V2 = QuantumCircuit(N_QUBITS, name="V2")
    # V2.x(0)
    result_2 = erft(U2, V2, epsilon=EPSILON, delta=DELTA)
    print(f"\nFinal Decision for Case 2: {result_2}\n")

    # --- Case 3: Nearly Equivalent Circuits (with a larger error) ---
    # Note: RX gates are not Clifford gates. We must use Clifford gates for this simulation.
    # We will replace the RX gates with a different non-equivalent Clifford pair.
    print("-" * 50)
    print("### Case 3: Testing Non-Equivalent Clifford Circuits ###")
    U3 = QuantumCircuit(N_QUBITS, name="U3")
    U3.h(0)
    U3.s(0)

    V3 = QuantumCircuit(N_QUBITS, name="V3")
    V3.h(0)
    # V3 is missing the S gate, making it non-equivalent.
    
    result_3 = erft(U3, V3, epsilon=EPSILON, delta=DELTA)
    print(f"\nFinal Decision for Case 3: {result_3}\n")

    
